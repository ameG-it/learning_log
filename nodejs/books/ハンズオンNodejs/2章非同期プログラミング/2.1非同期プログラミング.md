- プログラムの実行環境が状況に応じて実行するスレッドを切り替える
  コードによる表現が不要

マルチスレッドの問題点

- C10K 問題
  10,000 程度まで増加するとレスポンス性能が著しく低下する。
  例えば 1 スレッドに割り当てるスタックサイズが 2MB、メモリが 16GB の環境ではスレッドの上限は 8,000 となる
- コンテキストスイッチ
  スレッドの切り替えによるオーバーヘッド
  スレッドの状態を保存、復元するプロセスを伴うため大量のスレッドを同時に処理する状況下ではこれが大量に発生しオーバーヘッドが大きくなる

- プログラマへの制約
  処理が並行して走っても問題なく動作するようにする必要がある（スレッドセーフ）
  例えば同じ値を別々のスレッドから更新しても問題が発生しないなど。
  スレッドの実行タイミングは環境に委ねられているためタイミングの制御はプログラムからの制御はでなきない。
  回避策としてスレッド間での値の共有の禁止や、
  ロックをかけるなどあるが
  共有の禁止はいつでもできるとは限らず、ロックもデットロックなど単体テストで検出しにくい不具合を招くため解決が難しい

- シングルスレッドではこれらの問題がない

- ブロッキング I/O
  DB からのデータ取得などプログラムの実行を止めてしまうような外部通信を伴う処理を
  ブロッキング I/O という
  シングルスレッドの処理においてブロッキング I/O は処理完了まで実行が止められてしまう

- ノンブロッキング I/O
  時間のかかる処理でありながらプログラムを進行を止めない入出力をノンブロッキング I/O という

- 非同期処理
  ノンブロッキング I/O のように処理が完了していないにも関わらず次の処理にすすんでしまうような処理

イベントループで並列処理を実現するためには I/O はノンブロッキングである必要があるため、非同期プログラミングが重要

- 非同期プログラミング
  シングルスレッドはスレッドセーフの観点から安全と言えるが
  非同期プログラミング自体の複雑さが問題となることがある
  マルチスレッドとシングルスレッドは
  簡潔さと、柔軟さにおいてトレードオフの関係にあるといえる

  マルチスレッド
  スレッドの切り替えを実行環境が担っているため、多くのケースでコードの記述が簡潔になる
  並列処理をコードから制御することが難しく、スレッド間の値の共有や、ロックなどしだすとコードが却って複雑になる

  シングルスレッド
  並列処理を実現するために非同期プログラミング必要があるため記述が複雑になりやすい
  並列処理をコードで制御でき、スレッドセーフへの配慮が不要

nodejs のメリットを最大限に活かすためには適切な非同期プログラミングが必要

イベントループによる並列処理は非同期プログラミングを活用することで大量の I/O を処理するのに向いている一方
自身の CPU を使うようなタスクはそれが完了するまで次の処理に移れないため不向き
マルチスレッドの場合は大きなタスクの中でも別のスレッドを割り込ませて処理することができる
※一応 Nodejs でもマルチスレッドを使うことができるらしい

# まとめ

## Nodejs と非同期プログラミング

### 非同期処理

処理 A→B→C...のように順に処理していく処理を`逐次処理`という。
しかし、処理 B で外部 DB からデータを取得する場合などは CPU としては待ち時間となってしまう
この待ち時間を使って先に処理 C を行うように処理する場合がある。
このような動作を`非同期処理`という
Web アプリケーションの開発においては、サーバー処理の待ち時間の間、クライアント側で処理を進めておくなど
非同期処理の活用が不可欠になっている

### イベントループとマルチスレッド

非同期処理を実現するにあたり、マルチスレッドが一般的だったが、
Nodejs はシングルスレッドで処理するイベントループが採用されている。

### マルチスレッドの問題点

非同期処理を実現するにあたりマルチスレッドが一般的とされているが、
マルチスレッドによる非同期処理には問題もある、

- C10K 問題
  スレッド数が 10,000 程度まで増加するとレスポンス性能が著しく低下する問題。
  例えば 1 スレッドに割り当てるスタックサイズが 2MB、メモリが 16GB の環境ではスレッドの上限は 8,000 となる。

- コンテキストスイッチ
  スレッドの切り替え（スレッドの状態を保存、復元）時に発生するオーバーヘッド
  大量のスレッドを処理する際に問題となりやすい

- スレッドセーフへの配慮
  処理が並行して走っても問題なく動作するようにする必要がある（スレッドセーフ）
  例えば同じ値を別々のスレッドから更新しても問題が発生しないなど。
  ```
  スレッドの実行タイミングは環境に委ねられているためタイミングの制御はプログラムからの制御はでなきない。
  回避策としてスレッド間での値の共有の禁止や、
  ロックをかけるなどあるが
  共有の禁止はいつでもできるとは限らず、ロックもデットロックなど単体テストで検出しにくい不具合を招くため解決が難しい
  ```

### イベントループ

Nodejs はシングルスレッドで処理するイベントループが採用されている。
イベントループではスレッドの切り替えといった処理がないためスレッドセーフへの配慮が不要となる。
一方で並列処理を実現するためには非同期プログラミングする必要がある
シングルスレッドとマルチスレッドは
簡潔さと柔軟さにおいてトレードオフの関係にあると言える

イベントループ
⚪︎ 並列処理をコードで制御でき、スレッドセーフへの配慮が不要
× 非同期プログラミングが必須であり記述が複雑になる

マルチスレッド
⚪︎ 実行環境が並列処理を制御するため、多くのケースで記述が簡潔になる
× スレッド間の相互アクセスや資源のロックといった一部のケースではスレッドセーフへの配慮が必要となる

### Nodejs の強みを活かす

Nodejs では適切な非同期プログラミングを行うことで
I/O が発生する Web アプリケーションのおいて高いパフォーマンスを発揮できる
自身の CPU を使うようなタスクはそれが完了するまで次の処理に移れないため不向き
マルチスレッドの場合は大きなタスクの中でも別のスレッドを割り込ませて処理することができる
※一応 Nodejs でもマルチスレッドを使うことができるらしい
